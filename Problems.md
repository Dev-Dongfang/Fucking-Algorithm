[TOC]


有点难度的题目：
* 12：全排列
* 28: 字符串全排列问题

//字符串组合算法存在问题，题目28.



## 面试题5：从尾到头打印链表
> 输入一个链表的头节点，从尾到头反过来打印每个节点的值。

方法一：这道题不难，常规的做法就是使用一个栈，然后循环将每个元素放入栈中，最后输出每个出栈元素即可。

方法二：使用递归，当找到最后一个节点时开始输出元素，递归输出到第一个元素。缺点是，如果链表很长，可能导致堆栈溢出的问题，这时候使用方法一的做法比较好。


## 面试题7：用两个栈实现队列
> 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail和deleteHead，分别完成队列尾部插入结点和在队列头部删除结点的功能。

分析：这个题目主要是需要想到一个巧妙的思路，思路也不难，将入栈的元素放到第一个栈中，出栈的话从第二个栈中取，如果第二个栈为空，则将第一个栈中元素倒入第二个栈中，然后出栈即可。


## 面试题8：旋转数组的最小数字
> 题目：把一个数组最开始的若干个数字搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。

解法一：从头到尾循环遍历查找。

解法二：二分查找法。仔细思考发现，旋转之后数组实际上可以划分为两个排序的子数组，而前面排序的子数组元素都大于或者等于后面子数组的元素。更重要的是，最小元素刚好是这两个子数组的分界线。    使用两个指针指向l数组的第一个和最后一个元素。然后查找中间元素，如果中间元素大于等于第一个元素，则z这个元素属于前面的递增序列，最小值应该位于后半部分；反之最小值位于前半部分。依次循环，第一个指针总是指向d第一个总是指向前面递增序列，第二个指针总是指向后面的递增序列。当两个指针所指元素相邻时候，第二个指针所指的元素就是最小值。
**注意**：当两个指针所指位置的值相等，且中间位置值也相等时候就无法判断了，此时只能通过循环遍历来判断。r如果序列本来就是有序的，就是说第一个元素就是最小值的情况也需要特殊判断。


## 9.斐波那锲序列
> 题目1：写一个函数，输入n，求菲波那切数列的第n项是多少。

> 题目2：一只青蛙一次可以跳一个台阶，也可以跳两个台阶，求该青蛙跳上n个台阶总共有多少种跳法。


## 面试题10：二进制中1的个数
> 请实现一个函数，输入一个整数，输出z该整数二进制表示中1的个数。

解法一：首先让输入的整数n与1做位与运算，如果结果是1则表示这一位的二进制是1，然后让1左移一位，继续判断，以此类推即可判断二进制数字所有1的位数。这个解法中循环的次数等于整数二进制的位数，32位的的整数只需要循环32次即可。

解法二：这个解法更厉害了！首先需要明确二进制数字的一个原理：把一个整数的二进制减去1，再和原来的整数做与运算，会把该整数的最右边一个1变成0。根据这个原理，一个二进制数字中有多少个1就能够做多少次这样的位与运算。

位与原理可以解决的其它面试问题：

1. 判断一个整数是不是2的整数次方。分析：如果一个整数是2的整数次方，那么这个整数的二进制表示中只有一个1，利用位与运算原理，判断整数中二进制表示1的个数即可。
2. 输入两个数字m、n，计算需要改变m的二进制中多少位才能得到n。分析：根据题目，也就是判断两个数字中二进制表示不相同的比特位有多少个，首先我们将两个数字进行异或操作得到不同的位，然后统计异或操作后的数字的二进制1的个数即可。



## 面试题11：数值的整数次方
> 题目：实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。

看到这个题目，首先应该考虑的是参数的合法性，base是0怎么办，exponent是0怎么办，如果是负数怎么办，程序是否考虑到了边界问题等。

解法一：看到题目最先想到的一定是暴力方法，循环exponent次，每次都乘上base即可。这个方法没问题，但是却不够高效，如果这么简单的题目，肯定不会出现在面试题目中。

解法二：考虑使用数学公式简化运算(a^n = a^n/2 * a^n/2)。



## 面试题12：打印1到最大的n位数----全排列
> 题目：输入数字n，按顺序打印出从1到最大的n位十进制数，比如输入3，则打印出1、2、3...999。

分析：首先想到的肯定是从1开始遍历输出整数，但是这里有个陷阱，如果输入的n非常大，那么不管是Int还是long都无法表示出来。所以这种方法是不行的。

解法一：在字符串上模拟数字相加的算法。

解法二：其实n个十进制数就是n个从0~9的全排列，也就是说，我们把数字的每一位都从0~9排列一遍，就能得到所有的十进制数。


## 面试题13：在O(1)时间内删除链表节点
> 题目：给定一个单向链表头指针和一个节点指针，定义一个函数在O(1)时间内删除这个节点。

这个问题还是比较简单的，同样有两种解法。

解法一：书本中的解法，循环遍历每个节点，判断当前节点是否是需要删除的节点，如果是则将此节点后一个节点的内容赋值给当前节点，然后删除下一个结点即可。这里需要注意的是，如果要删除的节点位于链表的尾部，需要特殊处理一下。另外需要和面试官讨论将下一个结点内容复制到当前节点是可行的。

解法二：个人想法。首先判断如果要删除的节点是头结点，则直接删除，如果不是则循环遍历当前节点的下一个结点是否是要删除的节点，如果是则删除。


## 面试题14：调整数组顺序，使奇数位于偶数前面
> 题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数都位于数组的前半部分，偶数位于数组的后半部分。

这个题目思路也很容易想到，应该算是lc上简单级别的题目吧。这个问题可以用两个指针来解决，第一个指针指向开头位置，从前往后找到第一个偶数，第二个指针指向结尾，从后向前找到第一个奇数，交换两个数字位置，继续循环查找，直到两个指针相遇结束。

如果考虑扩展性，可以将判断条件参数化，swift中通过闭包来提供判断条件。


## 面试题15：链表中倒数第k个节点
> 输入一个链表，输出这个链表的倒数第k个节点。本题目从1开始计数。

这道题没啥好说的，快慢指针。

快慢指针能够解决的其它问题：

1. 求链表的中间节点。
2. 判断一个单链表是否想成环结构。


## 面试题16：反转单链表
> 题目：定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

解法1：定义一个头部的哨兵节点，以此遍历链接到新的链表上去。


## 面试题17：合并两个排序的链表
> 题目：输入两个递增排序的链表，合并这两个递增排序的链表并使新的链表仍然是递增排序的。

分析：这道题目实际上没有什么技巧，判断并将两个链表的头节点连接到新的链表上即可。关键是动手写代码之前需要考虑清楚代码应该怎么写，考虑好各种临界条件。



## 面试题19：二叉树的镜像
> 请完成一个函数，输入一个二叉树，该函数输出它的镜像。

分析：镜像，也就是说从二叉树根节点轴对称的二叉树。我们可以先序遍历这个树的每个节点，如果遍历到节点有子节点，就交换着这两个子节点的位置，当交换完毕所有非叶子节点的子节点之后，也就得到了二叉树的镜像。



## 面试题21：包含min函数的栈
> 题目：定义栈的数据结构，请在该结构中实现一个能够得到栈最小元素的min函数。调用min、push、pop的时间复杂度都是O
（1）

分析：我们可以使用辅助栈记录当前最小元素，辅助栈与数据栈保持相同的元素数量。


## 面试题23：从上往下打印二叉树
> 题目：从上往下打印二叉树的每个节点，同一层的节点按照从左到右的顺序打印。

分析：这道题实质上是在考树的遍历算法，只不过不是我们熟悉的前序、中序、后序遍历。按层遍历二叉树，最简单的做法是使用队列来解。

扩展：如何广度优先遍历一个有向图？解决方法和这个题目类似，同样可以基于队列来实现。树是图的一种退化形式，从上到下遍历二叉树，从本质上来说就是广度优先遍历二叉树。



## 面试题25：二叉树中和为某一值的路径
> 题目：输入一个二叉树和一个整数，打印出二叉树中节点值的和是输入整数的所有路径。从树的根节点开始往下一直到页节点所经过的节点形成一条路径。

分析：既然是找到所有的路径，那势必需要遍历每个路径并判断是够符合条件，如果不符合还要回退判断下个路径，因此最合适的算法就是**回溯算法**。



## 面试题26：复杂链表的复制
> 请实现一个函数，复制一个复杂的链表。在复杂链表中除了有一个next指针指向下一个结点，还有一个sibling指针指向链表中的任意结点或者NULL。结点和简单的示例如下图所示：

![](./WX20200217-184541@2x.png)

解法一：第一步复制原始链表上的每个节点N创建N‘，然后将新创建出来的节点使用next指针连起来。同时使用哈希表建立N和N’的映射关系。第二步设置sibling指针，从哈希表中找到匹配的N‘。

解法二：解法一使用哈希表的方法进行复杂链表的复制，其实我们不借助哈希表也能实现。第一步仍然是根据原始节点复制新的节点，不过我们将新的节点连接到原始链表的后面。第二步，修正N’的sibling指针，并将N‘从原始的链表中分离出来。算法的复杂度比解法一要复杂一点，但是更节省空间，时间复杂度也是相同的。


## 面试题28：字符串的排序
> 题目：输入一个字符串，打印出该字符串中字符的所有排序。例如，输入abc，则输出a/b/c三个字符的所有排列。

分析：字符串全票列可以把字符串看成两部分，第一部分为它的一个字符，第二部分是后面的字符。代码分两步完成，首先求所有可能出现在第一个位置的字符，即把第一个字符与后面的所有字符交换。第二步固定第一个字符，求后面所有字符的排列，这里可以看出是典型的递归思路。

https://www.cnblogs.com/boris1221/p/9388209.html



## 面试题29：数组中出现次数超过一半的数字
> 题目：数组中有一个数字出现的次数超过数组长度的一般，请找出这个数字。

解法一：使用哈希表统计数组中对应数字出现的次数，然后便利哈希表找到次数最大的那个数字。

解法二：先排序，找中位数即是你要找的数字。

解法三：我们只需要找到数组中位数即可，根据快排的思想，没必要给整个数组全部排序，只需根据分支思想找到中位数即可。

解法四：我们可以考虑在遍历数组的同时保留两个值：一个是数组中的一个数字，另一个是这个数字出现的次数，如果下个数字和当前的相同则次数加1，不同则减1，当次数为0时候，重置数字和次数。最终保留下来的数字就是数组中出现次数最多的数字。




## 面试题30：最小的k个数
> 输入n个整数，找出其中最小的k个数。例如输入4、5、1、6、2、7、3、8、这八个数字，则最小的4个数字是1、2、3、4.

解法一：使用分治算法，快排的思想，但是不需要完全排序，只需查找排序数组中第k个位置即可，找到后，在k位置之前的就是需要查找的k个数字。

解法二：使用大顶堆。构建包含k个数字的大顶堆，遍历过程中以此比较并将新的小的数据插入大顶堆中。这种算法适合海量数据的p查找操作，很多家大公司喜欢问海量数据相关的问题。



## 面试题31：连续子数组的最大和
> 输入一个整数数组，数组里面有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组和的最大值。要求时间复杂度是O(n)。

分析：简单分析我们发现，我们只需连续累加子数组中的值即可，如果累加结果是负数，则舍弃前面所有累加的结果，重新在新的位置开始累加。


## 面试题34：丑数
> 题目：我们把只包含因子2、3、5的数称作丑数。求从小到大排序的第1500个丑数。习惯上我们把1当成第一个丑数。

解法一：逐个判断每个数是不是丑数，直观但是不够高效。

解法二：创建数组保存已经找到的丑数，用空间换时间的解法。



## 面试题35：第一个只出现一次的字符
> 在字符串中找出第一个只出现一次的字符。如输入abaccdeff，则输出b。

分析：借助哈希表存储字符出现的次数，第一次遍历找出每个字符出现的次数并存储到哈希表中，第二次遍历找出第一个出现一次的字符。


## 面试题37：两个链表的第一个公共节点
> 题目：输入一个链表，找出它们的第一个公共节点。（类似于iOS中查找两个子视图的第一个公共父视图算法）

解法一：分别循环遍历两个链表，将每个节点存放到一个栈中，然后依次出栈，找出第一个不相同的即可找出第一个相同的公共节点。

解法二：先分别遍历统计两个链表的长度，让长的链表先走几步知道两个链表剩余节点相同，然后同时移动两个链表，找到第一个相同的节点即可。



## 面试题38：数字在排序数组中出现的次数
> 题目：统计一个数字在排序数组中出现的次数。例如输入排序数组{1,2,3,3,3,3,4,5}和数字3，由于3在这个数组中出现了4次，因此输出4.

分析：既然输入数组是排序的，那么很自然的我们想到用二分查找算法。我们可以先找到第一个3，然后再找到最后一个3，两个位置的差值即是3的个数。






## 面试题39：二叉树的深度
> 题目一：输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点以此经过的节点形成树的一条路径，最长路径的长度为树的深度。

解法一：递归法，树的深度可以看成是左右子树深度最高的那个深度加一。递归实现即可。

> 题目二：输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意结点的左右子树深度相差不超过1，那么它就是一棵平衡二叉树。

解法一：根据题目一的解法思路来解决，递归调用判断每个节点是否是二叉树。方法是可行的，但是每个节点都被重复的遍历多次，效率不高。

解法二：使用后序遍历的方式，先判断左右子树是不是平衡二叉树，然后返回左右子树的深度，最后比较根节点的左右子树即可。




## 面试题40：数组中只出现一次的数字
> 题目：一个整形数组中，除了两个数字之外，其它数字都出现了两次，请写程序找出这两个只出现一次的数字。要求时间复杂度O(n)，空间复杂度O(1)。

分析：异或运算的性质：任何一个数字异或它自己都等于0。也就是说，我们从头到尾异或数组中中出现的每一个数字，那么最终结果刚好是那个只出现一次的数字，因为那些成对出现的数字全部在异或操作中抵消了。

解法一：第一次循环遍历统计数组中每个数字数显的次数，第二次遍历查找到出现次数为1的数字是多少。

解法二：利用异或的特性。首先对整数数组进行异或操作，异或操作的结果肯定是两个不相同数字的异或，因为其它相同的数字全部在异或操作中抵消了。随后我们找到连那个那个不同数字异或结果中第一个为1的比特位。随后我们根据这个比特位是否为1将整个数组分成两个子数组，那么两个不同的数字肯定会被分配到两个子数组中。随后我们根据从数组中找出只包含一位不同数字的解法即可解决。



## 面试题41：和为s的两个数字VS和为s的连续正数序列
> 题目：输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，输出任意一对即可。

解法一：哈希法。定义一个hashmap，第一次循环遍历，key为目标数字与当前数字的差，value为当前数字。第二次循环遍历查找差在hash中是否存在。

解法二：夹逼法：a+b=sum，详见剑指offer，p214.

https://www.jianshu.com/p/85f18c2e27c8



## 面试题42：反转单词顺序 VS 左旋转字符串
> 题目一：输入一个英文句子，反转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入"I am a student."。则输出"student. a am I"。

解法一：第一步，反转句子中所有的字符。第二步，反转每个单词中字符的顺序。

> 题目二：字符串的左旋操作是把字符串的前n个字符串转移到字符串的尾部。请定义一个函数实现字符串左旋操作的功能。比如输入abcdefg和2，则输出cdefgab。

解法一：创建新的字符数组，第一步，先将第n个字符之后的字符循环输入到新的字符数组中；第二步，将前面n个字符放到字符数组的结尾即可。

解法二：通过旋转字符串实现。第一步，旋转字符串前n个字符，第二步，旋转剩余的字符数组，第三步，旋转整个字符串。



## 面试题44：扑克牌的顺子
> 题目：从扑克牌中随机抽取5张，判断是不是一个顺子，即这5张牌是不是连续的。2~10为数字本身，A为1，J为11，Q为12，K为13，而大小王可以看成是任意数字。

分析：首先将整个数组排序，然后统计数组红0的个数，最后统计排序后数组中相邻数字之间l空缺的个数，如果空缺的个数小于等于0的个数，那么这个数组就是连续的，反之则不连续。





## 面试题47：不用加减乘除做加法
> 题目：写一个函数，求两个整数之和，要求在函数体内不能使用加减乘除四则运算符号。

分析：既然不能使用四则运算符，那么我们只能尝试通过位运算了。我们分析人们怎么做十进制加法运算，实际上可以分为三步：1.只做各位相加不进位；2.做进位操作；3.将前两步的结果加起来。












## 算法题目面试技巧
1.  在面试中，你也可以提醒面试官注意你编码中考虑到的细节问题，以让他知道我们对编程的细节非常重视。
2. 在你开始编码之前，一定要和面试官讨论关于题目中的细节问题，提出你编码的假设，这样面试官会觉得你考虑问题非常全面。
3. 算法题目中，一定要考虑算法的扩展性！这个能给自己加分。
4. 面试的时候，很重要的一点是应聘者要表现出很快的反应能力。只要想到一种方法，应聘者就可以马上告诉面试官，即使这个方法不一定的最好的。





## 技巧总结
在计算机语言中，位运算比乘除法运算的效率高很多，因此我们应当尽可能的使用位运算来进行计算操作。

### 1.使用&判断奇偶数效率更高
在算法题目中，判断奇偶还是比较常见的，比较高效的方法是使用&操作符，具体代码如下所示：

```swift
if n & 0x1 == 1 {
    //奇数
}else{
    //偶数
}
```

### 2.使用>>或者<<计算乘除法
在计算机中，位运算的效率比乘除法的效率高很多，因此在算法题目中，一般我们需要使用左移或者右移来计算乘2或者除2的操作。

```swift
//右移除以二
n << 1
//左移乘以二
n >> 1
```

### 3.哨兵节点
如果面试题目是链表相关的题目，注意使用**哨兵节点**，使用哨兵节点可以减少很多临界条件的判断。

### 4.二进制运算技巧1
把一个整数减去1再和原整数做位与运算，得到结果相当于把整数二进制表示中最右边一个1变成0。很多二进制相关的问题都可以用这个思路解决。

### 5.异或运算技巧
异或运算的性质：任何一个数字异或它自己都等于0。也就是说，我们从头到尾异或数组中中出现的每一个数字，那么最终结果刚好是那个只出现一次的数字，因为那些成对出现的数字全部在异或操作中抵消了。









 
